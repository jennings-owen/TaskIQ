# CI/CD Pipeline Documentation

**Version**: 2.0  
**Date**: November 5, 2025  
**Status**: ACTIVE

---

## Overview

Comprehensive CI/CD pipeline using GitHub Actions that automatically runs the full test suite (192+ tests) via Docker Compose on every push to main, master, or develop branches.

---

## Pipeline Architecture

### Docker-Based Testing

The pipeline uses `docker-compose.test.yml` to run all tests in isolated containers:

**Key Features**:
- Single job execution via Docker Compose
- Test database (test.db) mounted for integration tests
- Automatic test.db generation if missing
- Coverage reports extracted from containers
- Test logs captured as artifacts

**Benefits**:
- Consistent test environment (local and CI)
- Simplified pipeline configuration
- Faster execution (parallel container startup)
- Easier debugging (same commands locally and in CI)

---

## Test Suite Breakdown

### Backend Tests (127+ tests)

| File | Tests | Purpose | Coverage |
|------|-------|---------|----------|
| `test_tasks.py` | 36 | CRUD operations, performance, security | Core API |
| `test_ai.py` | 35 | AI endpoints, algorithm validation | AI features |
| `test_database.py` | 32 | Database constraints, integrity | Data layer |
| `test_integration.py` | 21 | Full workflows, dependencies | Integration |
| **Total** | **124** | **Comprehensive backend coverage** | **All layers** |

### Frontend Tests (65+ tests)

| File | Tests | Purpose | Coverage |
|------|-------|---------|----------|
| `TaskList.test.jsx` | ~20 | Component rendering, interactions | Task display |
| `TaskForm.test.jsx` | ~25 | Form validation, submission | Task creation |
| `Dashboard.test.jsx` | ~20 | Analytics, charts, real-time | Dashboard |
| **Total** | **~65** | **Complete UI coverage** | **All components** |

---

## Workflow Triggers

The CI/CD pipeline runs on:

1. **Push** to main, master, or develop branches only

---

## Pipeline Job

### docker-test-suite

**Purpose**: Run complete test suite in Docker containers

**Steps**:
1. Checkout code
2. Set up Docker Buildx
3. Verify test.db exists (auto-generated if missing)
4. Validate docker-compose.test.yml configuration
5. Build test images (backend and frontend)
6. Run full test suite via Docker Compose
7. Extract test results and logs from containers
8. Upload test logs as artifacts
9. Extract coverage reports from containers
10. Upload coverage to Codecov
11. Cleanup containers and volumes
12. Generate comprehensive test summary

**Success Criteria**: All tests pass in Docker containers

**Execution Time**: ~5-10 minutes

---

## Docker Compose Test Configuration

### docker-compose.test.yml

**Backend Service** (`backend-test`):
```yaml
- Runs pytest with coverage
- Mounts test.db (read-only)
- Environment: TESTING=true, DATABASE_PATH=/app/tests/test.db
- Health check on port 8000
- Command: pytest → uvicorn
```

**Frontend Service** (`frontend-test`):
```yaml
- Runs npm test with coverage
- Depends on backend health check
- Environment: CI=true
- Health check on port 3000
- Command: npm test → npm start
```

**Network**: `synapseSquad-test-network` (isolated)

---

## Test Database

### backend/tests/test.db

**Purpose**: Persistent test database for integration tests

**Contents**:
- Sample users
- Sample tasks with various states
- Task dependencies
- Priority and t-shirt size scores
- Realistic test data

**Management**:
- Auto-generated by conftest.py if missing
- Committed to repository
- Mounted read-only in Docker containers
- Ensures consistent test data

---

## Running Tests Locally

### Using docker-start Script (Recommended)

**Windows:**
```powershell
.\docker-start.ps1 -Test
```

**Linux/Mac:**
```bash
./docker-start.sh -Test
```

**What it does**:
1. Checks for test.db (auto-generates if missing)
2. Builds test images (if needed)
3. Starts backend and frontend test containers
4. Runs full backend test suite (127+ tests)
5. Runs full frontend test suite (65+ tests)
6. Generates coverage reports inside containers
7. Exits when backend tests complete
8. Shows helpful commands for viewing logs and cleanup

### Using Docker Compose Directly

**Run tests:**
```bash
docker-compose -f docker-compose.test.yml up --abort-on-container-exit --exit-code-from backend-test
```

**Run tests with automatic cleanup:**
```bash
docker-compose -f docker-compose.test.yml up --abort-on-container-exit --exit-code-from backend-test && \
docker-compose -f docker-compose.test.yml down -v
```

### View Logs

```bash
# View backend test results
docker-compose -f docker-compose.test.yml logs backend-test

# View frontend test results
docker-compose -f docker-compose.test.yml logs frontend-test

# Follow logs in real-time
docker-compose -f docker-compose.test.yml logs -f
```

### Cleanup

```bash
# Remove containers and volumes
docker-compose -f docker-compose.test.yml down -v
```

### Additional Commands

```bash
# Validate configuration
docker-compose -f docker-compose.test.yml config

# Build images only
docker-compose -f docker-compose.test.yml build

# Rebuild without cache
docker-compose -f docker-compose.test.yml build --no-cache
```

### Direct Test Execution

**Backend Tests**:
```bash
cd backend
pytest tests/ -v                    # Run all tests
pytest --cov=. --cov-report=html    # With coverage
pytest tests/test_tasks.py -v       # Specific file
```

**Frontend Tests**:
```bash
cd frontend
npm test                            # Run all tests
npm test -- --coverage              # With coverage
npm test TaskList.test.jsx          # Specific file
```

---

## Coverage Requirements

### Backend Coverage
- **Minimum**: 80%
- **Target**: 85%+
- **Critical Paths**: 95%+
- **Enforced**: Yes (pipeline fails if below 80%)

### Frontend Coverage
- **Tracked**: Yes
- **Reported**: Yes
- **Enforced**: No (informational only)

---

## Artifacts

The pipeline generates and uploads the following artifacts:

| Artifact | Retention | Purpose |
|----------|-----------|---------|
| `test-logs` | 30 days | Backend and frontend test execution logs |
| `coverage-reports` | 30 days | Backend coverage (XML and HTML) |
| Codecov upload | Permanent | Coverage tracking and badges |

### Accessing Artifacts

1. Go to GitHub Actions → Workflow run
2. Scroll to "Artifacts" section
3. Download `test-logs` or `coverage-reports`
4. Extract and view HTML coverage reports

---

## Pipeline Configuration Files

### .github/workflows/ci.yml
Main CI/CD pipeline with Docker-based test execution.

**Key Features**:
- Single job for all tests
- Docker Compose integration
- Coverage extraction from containers
- Artifact uploads
- Summary generation

### docker-compose.test.yml
Test-specific Docker Compose configuration.

**Key Features**:
- Test database mounting
- Test-specific environment variables
- Health checks for service readiness
- Test execution before service startup

### run-tests.ps1 / run-tests.sh
CLI scripts for local test execution.

**Key Features**:
- `-Test` flag for execution
- Color-coded output
- Automatic cleanup
- Exit code propagation

---

## Monitoring Pipeline Status

### GitHub Actions UI
1. Go to repository → Actions tab
2. View recent workflow runs
3. Click on a run to see details
4. Download artifacts if needed
5. View test summary in job output

### Pull Request Checks
- Status checks appear on PR page
- Required checks must pass before merge
- Click "Details" to view logs
- Review coverage changes

---

## Troubleshooting

### Tests Failing in CI

**Check**:
1. Review test logs artifact
2. Check coverage reports
3. Verify test.db exists
4. Review Docker build logs

**Fix**:
```bash
# Run locally with same configuration
.\run-tests.ps1 -Test  # Windows
./run-tests.sh -Test   # Linux/Mac

# Check specific logs
docker-compose -f docker-compose.test.yml logs backend-test
docker-compose -f docker-compose.test.yml logs frontend-test
```

### Docker Build Failures

**Check**:
1. Dockerfile syntax
2. Dependency versions in requirements.txt / package.json
3. Build context size

**Fix**:
```bash
# Test build locally
docker-compose -f docker-compose.test.yml build --no-cache

# Check individual services
docker build -t test-backend ./backend
docker build -t test-frontend ./frontend
```

### Coverage Below Threshold

**Check**:
```bash
cd backend
pytest --cov=. --cov-report=term-missing
```

**Fix**: Add tests for uncovered code paths

### test.db Missing or Corrupt

**Fix**:
```bash
# Delete and regenerate
rm backend/tests/test.db
cd backend
python -c "from tests.conftest import _create_test_database; _create_test_database('tests/test.db')"
```

---

## Best Practices

### Before Pushing Code

1. **Run tests locally via Docker**:
   ```bash
   .\run-tests.ps1 -Test  # Windows
   ./run-tests.sh -Test   # Linux/Mac
   ```

2. **Check coverage**:
   ```bash
   cd backend && pytest --cov=. --cov-report=term
   ```

3. **Verify test.db**:
   ```bash
   # Should exist and be valid SQLite database
   sqlite3 backend/tests/test.db ".tables"
   ```

### Pull Request Guidelines

1. Ensure Docker test suite passes locally
2. Review coverage reports
3. Update tests for new features
4. Keep PRs focused and small
5. Include test.db if schema changes

### Maintaining Tests

1. Keep tests fast (< 10 minutes total)
2. Maintain 80%+ backend coverage
3. Update tests when changing code
4. Add tests for bug fixes
5. Remove obsolete tests
6. Keep test.db synchronized with schema

---

## Performance Metrics

### Target Execution Times

| Stage | Target | Acceptable | Action if Exceeded |
|-------|--------|------------|-------------------|
| Docker Build | 2 min | 5 min | Optimize Dockerfile layers |
| Backend Tests | 2 min | 5 min | Optimize slow tests |
| Frontend Tests | 2 min | 4 min | Review test complexity |
| Total Pipeline | 6 min | 10 min | Investigate bottlenecks |

### Optimization Tips

1. **Docker layer caching**: Order Dockerfile commands by change frequency
2. **Parallel test execution**: pytest-xdist for backend
3. **Selective testing**: Use pytest markers for slow tests
4. **Test database**: Keep test.db small but representative

---

## CLI Scripts

### run-tests.ps1 (Windows PowerShell)

**Usage**:
```powershell
.\run-tests.ps1 -Test
```

**Features**:
- Color-coded output
- Progress indicators
- Automatic cleanup
- Exit code propagation
- Usage help without -Test flag

### run-tests.sh (Linux/Mac)

**Usage**:
```bash
./run-tests.sh -Test
```

**Features**:
- ANSI color output
- Progress indicators
- Automatic cleanup
- Exit code propagation
- Usage help without -Test flag

---

## Future Enhancements

### Planned Improvements

1. **Performance testing**: Add load testing to Docker suite
2. **E2E testing**: Selenium/Playwright in containers
3. **Deployment**: Auto-deploy on successful merge
4. **Notifications**: Slack/Teams integration
5. **Metrics**: Track test execution trends

### Optional Additions

1. **Mutation testing**: Verify test quality
2. **Visual regression**: Screenshot comparisons
3. **Accessibility testing**: WCAG compliance in containers
4. **API testing**: Postman/Newman integration

---

## Support and Documentation

### Related Documents
- [TEST_SUITE_OVERVIEW.md](TEST_SUITE_OVERVIEW.md) - Complete test documentation
- [TEST_SUITE_ANALYSIS.md](TEST_SUITE_ANALYSIS.md) - Test necessity analysis
- [PRD.md](PRD.md) - Product requirements
- [SETUP.md](SETUP.md) - Local development setup
- [../README.md](../README.md) - Main documentation with quick start
- [../DOCKER_START_GUIDE.md](../DOCKER_START_GUIDE.md) - Docker usage guide

### Getting Help

1. **Pipeline issues**: Check GitHub Actions logs and artifacts
2. **Test failures**: Review test-logs artifact
3. **Coverage issues**: Download coverage-reports artifact
4. **Docker issues**: Run locally with same docker-compose.test.yml
5. **General questions**: See TEST_SUITE_OVERVIEW.md

---

## Sign-off

**Pipeline Version**: 2.0  
**Test Suite Version**: 3.0  
**Status**: ACTIVE  
**Last Updated**: November 5, 2025  
**Maintained By**: Integration & Testing Team

---

## Quick Reference

### Pipeline Status Badge

Add to README.md:
```markdown
![CI/CD Pipeline](https://github.com/YOUR_ORG/YOUR_REPO/actions/workflows/ci.yml/badge.svg)
```

### Key Commands

```bash
# Run full test suite (recommended)
.\docker-start.ps1 -Test  # Windows
./docker-start.sh -Test   # Linux/Mac

# Start development environment (hot-reload)
.\docker-start.ps1 -Dev  # Windows
./docker-start.sh -Dev   # Linux/Mac

# Start production environment (optimized)
.\docker-start.ps1  # Windows
./docker-start.sh   # Linux/Mac

# Or use docker-compose directly
docker-compose -f docker-compose.test.yml up --abort-on-container-exit --exit-code-from backend-test

# View test logs
docker-compose -f docker-compose.test.yml logs backend-test
docker-compose -f docker-compose.test.yml logs frontend-test

# Cleanup
docker-compose -f docker-compose.test.yml down -v

# Direct test execution (without Docker)
cd backend && pytest tests/ -v --cov=.
cd frontend && npm test -- --coverage

# Check test.db
sqlite3 backend/tests/test.db ".tables"
```

### File Structure

```
.
├── .github/
│   └── workflows/
│       ├── ci.yml                    # Main CI/CD pipeline
│       └── security.yml              # Security scanning
├── backend/
│   └── tests/
│       ├── conftest.py               # Pytest fixtures, auto-generates test.db
│       ├── test.db                   # Test database (committed)
│       ├── test_tasks.py             # 36 tests
│       ├── test_ai.py                # 35 tests
│       ├── test_database.py          # 32 tests
│       └── test_integration.py       # 21 tests
├── docker-compose.yml                # Production configuration
├── docker-compose.test.yml           # Test configuration
├── docker-start.ps1                  # Start prod/dev/test (Windows)
├── docker-start.sh                   # Start prod/dev/test (Linux/Mac)
├── DOCKER_START_GUIDE.md             # Complete Docker usage guide
└── README.md                         # Main documentation with quick start
```

---

**End of Documentation**
